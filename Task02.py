'''Даны две непустые очереди; начало и конец первой равны A1 и A2, авторой—A3 и A4. Очереди содержат одинаковое количество элементов.
Объединить очереди в одну,вкоторой элементы исходных очередей чередуются (начиная с первого элемента первой очереди).
Вывести ссылки на начало и конец полученной очереди. Новые объекты типа Node не создавать.'''
class Node:
    def __init__(self, value):
        self.value = value
        self.next = None

def queue(n):  # Функция для создания очереди
    values = list(map(int, input(f"Введите {n} элементов(а) очереди через пробел: ").split()))

    head = Node(values[0])  # Создаём первый узел (голову очереди)
    tail = head  # Хвост очереди пока совпадает с головой
    for value in values[1:]:  # Перебираем оставшиеся элементы
        tail.next = Node(value)  # Создаём новый узел и присоединяем его к хвосту
        tail = tail.next  # Обновляем указатель на хвост
    return head, tail  # Возвращаем указатели на голову и хвост очереди

def queues(A1, A3):  # Функция объединения двух очередей с чередованием элементов
    head = A1  # Начало новой очереди — это начало первой очереди
    tail = None
    cur1, cur2 = A1, A3  # Указатели на текущие элементы первой и второй очередей

    while cur1 and cur2:  # Пока в обеих очередях есть элементы
        next1, next2 = cur1.next, cur2.next  # Сохраняем следующие элементы обеих очередей
        cur1.next = cur2  # Связываем текущий элемент первой очереди с текущим элементом второй

        if next1:  # Если в первой очереди ещё есть элементы
            cur2.next = next1  # Связываем текущий элемент второй очереди со следующим элементом первой
        else:
            tail = cur2  # Если первая очередь закончилась, последний элемент — это cur2
        cur1, cur2 = next1, next2  # Переход к следующим элементам очередей

    if not tail:  # Если хвост не был обновлён
        tail = A1 if cur1 else A3  # Хвост — последний оставшийся элемент одной из очередей

    return head, tail  # Возвращаем голову и хвост объединённой очереди

def print_queue(head):
    cur = head  # Начинаем с головы очереди
    while cur:  # Пока не дойдём до конца списка
        print(cur.value, end=" -> ")  # Выводим значение текущего узла
        cur = cur.next  # Переход к следующему узлу
    print("None")  # Указываем конец очереди

n = int(input("Введите количество элементов в каждой очереди: "))

A1, A2 = queue(n)  # Создаём первую очередь
A3, A4 = queue(n)  # Создаём вторую очередь

head, tail = queues(A1, A3)  # Объединяем очереди чередованием элементов

print("\nОбъединённая очередь:")
print_queue(head)
print(f"Head: {head.value}, Tail: {tail.value}")

'''Введите количество элементов в каждой очереди: 4
Введите 4 элементов(а) очереди через пробел: 1 3 5 7
Введите 4 элементов(а) очереди через пробел: 2 4 6 8

Объединённая очередь:
1 -> 2 -> 3 -> 4 -> 5 -> 6 -> 7 -> 8 -> None
Head: 1, Tail: 8'''